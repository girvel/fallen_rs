use std::thread;
use std::sync::{Arc, Mutex};

use crate::components::{Entity, Positioned};
use crate::ecs::{CanRegister, HasComponent, component_mut};
use crate::entities::{Player, Ghost};


fn gravitate_down<
    T: HasComponent<Positioned> + Entity
>(entity: &mut T) {
    component_mut::<Positioned, _>(entity).position.1 += 1;
}


// ECS: autogenerated section //

#[derive(Default)]
pub struct GravitySystem {
    players: Vec<Player>,
    ghosts: [Arc<Mutex<Vec<Ghost>>>; 6],
    next_used_ghost_vec: usize,
}

impl GravitySystem {
    pub fn new() -> Self {
        Default::default()
    }

    pub fn update(&mut self) {
        for player in &mut self.players {
            gravitate_down(player);
        }

        let mut handles = vec![];

        for ghost_vec in &mut self.ghosts {
            let mut ghost_vec = Arc::clone(ghost_vec);
            handles.push(thread::spawn(move || {
                for ghost in ghost_vec.lock().unwrap().iter_mut() {
                    gravitate_down(ghost);
                }
            }));
        };

        for handle in handles {
            handle.join().unwrap();
        }
    }
}

// TODO pointer to entity to register in multiple systems
impl CanRegister<Player> for GravitySystem {
    fn register(&mut self, entity: Player) {
        self.players.push(entity);
    }
}

impl CanRegister<Ghost> for GravitySystem {
    fn register(&mut self, entity: Ghost) {
        self.ghosts[self.next_used_ghost_vec].lock().unwrap().push(entity);
        self.next_used_ghost_vec = (self.next_used_ghost_vec + 1) % 6;
    }
}
