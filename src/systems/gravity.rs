// use crate::components::{Displayed, Entity, Positioned};
// use crate::ecs::{CanRegister, component, HasComponent};
// use crate::entities::ghost::Ghost;
// use crate::entities::player::Player;
//
//
// fn gravitate<
//     T1: Entity + HasComponent<Positioned>,
//     T2: Entity + HasComponent<Displayed>,
// >(first: &T1, second: &T2) {
//     println!(
//         "#1 has position {} and #2 has character {}",
//         component::<Positioned, _>(first).position,
//         component::<Displayed, _>(second).character
//     );
//
//     // TODO tell if first and second are the same
// }
//
//
// // ECS: autogenerated section //
//
// pub struct GravitySystem {
//     players: Vec<Player>,
//     ghosts: Vec<Ghost>,
// }
//
// impl GravitySystem {
//     pub fn new() -> Self {
//         Self {
//             players: vec![],
//             ghosts: vec![]
//         }
//     }
//
//     pub fn update(&self) {
//         for a1 in &self.players {
//             for a2 in &self.players {
//                 gravitate(a1, a2);
//             }
//         }
//
//         for a1 in &self.ghosts {
//             for a2 in &self.players {
//                 gravitate(a1, a2);
//             }
//         }
//     }
// }
//
// // TODO pointer to entity to register in multiple systems
// impl CanRegister<Player> for GravitySystem {
//     fn register(&mut self, entity: Player) {
//         self.players.push(entity);
//     }
// }
//
// impl CanRegister<Ghost> for GravitySystem {
//     fn register(&mut self, entity: Ghost) {
//         self.ghosts.push(entity);
//     }
// }