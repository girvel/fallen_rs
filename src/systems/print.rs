use crate::components::{Displayed, Named, Positioned};
use crate::ecs::{AwareOfComponent, CanRegister, component, HasComponent, try_component};
use crate::entities::ghost::Ghost;
use crate::entities::player::Player;


// ECS better syntax like has_components!(Named, Positioned)
fn print_name_and_position<
    T: HasComponent<Named> + HasComponent<Positioned> +
    AwareOfComponent<Named> + AwareOfComponent<Positioned> + AwareOfComponent<Displayed>
>(entity: &T) {
    let postfix = try_component::<Displayed, _>(entity)
        .map_or(String::from(""), |displayed| format!(" ({})", displayed.character));

    println!(
        "{}{} at {}",
        component::<Named, _>(entity).name,
        postfix,
        component::<Positioned, _>(entity).position,
    );
}


// ECS: autogenerated section //

pub struct PrintSystem {
    players: Vec<Player>,
    ghosts: Vec<Ghost>,
}

impl PrintSystem {
    pub fn new() -> Self {
        PrintSystem {
            players: vec![],
            ghosts: vec![]
        }
    }

    pub fn update(&self) {
        for player in &self.players {
            print_name_and_position(player);
        }

        for ghost in &self.ghosts {
            print_name_and_position(ghost);
        }
    }
}

// TODO pointer to entity to register in multiple systems
impl CanRegister<Player> for PrintSystem {
    fn register(&mut self, entity: Player) {
        self.players.push(entity);
    }
}

impl CanRegister<Ghost> for PrintSystem {
    fn register(&mut self, entity: Ghost) {
        self.ghosts.push(entity);
    }
}