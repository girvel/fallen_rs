use crate::vector::Vector2;

mod vector;  // TODO figure out what to do with this thing


// ABSTRACT STUFF

trait HasComponent<T> {
    fn get_component_raw(&self) -> &T;
}

fn component<C, E: HasComponent<C>>(entity: &E) -> &C {
    HasComponent::<C>::get_component_raw(entity)
}

trait AwareOfComponent<T> {
    fn try_get_component_raw(&self) -> Option<&T>;
}

fn try_component<C, E: AwareOfComponent<C>>(entity: &E) -> Option<&C> {
    AwareOfComponent::<C>::try_get_component_raw(entity)
}


// COMPONENTS

struct Named {
    name: String,
}

struct Positioned {
    position: Vector2<i32>,
}

struct Displayed {
    character: String,
}


// ENTITIES

// ECS: components' types are parameters when defining new entity
struct Player {
    named: Named,
    positioned: Positioned,
    displayed: Displayed,
}

// ECS: easily autogenerated code
impl HasComponent<Named> for Player {
    fn get_component_raw(&self) -> &Named {
        &self.named
    }
}

impl HasComponent<Positioned> for Player {
    fn get_component_raw(&self) -> &Positioned {
        &self.positioned
    }
}

impl HasComponent<Displayed> for Player {
    fn get_component_raw(&self) -> &Displayed {
        &self.displayed
    }
}

// ECS: still easily autogenerated
impl AwareOfComponent<Named> for Player {
    fn try_get_component_raw(&self) -> Option<&Named> {
        Some(&self.named)
    }
}

impl AwareOfComponent<Positioned> for Player {
    fn try_get_component_raw(&self) -> Option<&Positioned> {
        Some(&self.positioned)
    }
}

impl AwareOfComponent<Displayed> for Player {
    fn try_get_component_raw(&self) -> Option<&Displayed> {
        Some(&self.displayed)
    }
}

struct Ghost {
    named: Named,
    positioned: Positioned,
}

impl HasComponent<Named> for Ghost {
    fn get_component_raw(&self) -> &Named {
        &self.named
    }
}

impl HasComponent<Positioned> for Ghost {
    fn get_component_raw(&self) -> &Positioned {
        &self.positioned
    }
}

impl AwareOfComponent<Named> for Ghost {
    fn try_get_component_raw(&self) -> Option<&Named> {
        Some(&self.named)
    }
}

impl AwareOfComponent<Positioned> for Ghost {
    fn try_get_component_raw(&self) -> Option<&Positioned> {
        Some(&self.positioned)
    }
}

impl AwareOfComponent<Displayed> for Ghost {
    fn try_get_component_raw(&self) -> Option<&Displayed> {
        None
    }
}

// TODO print for multiple entities
// TODO mutable components
// TODO split into files

// ECS better syntax like HasComponents<Named, Positioned> or has_components!(Named, Positioned)
fn print_name_and_position<
    T: HasComponent<Named> + HasComponent<Positioned> +
    AwareOfComponent<Named> + AwareOfComponent<Positioned> + AwareOfComponent<Displayed>
>(entity: &T) {
    let postfix = try_component::<Displayed, _>(entity)
        .map_or(String::from(""), |displayed| format!(" ({})", displayed.character));

    println!(
        "{}{} at {}",
        component::<Named, _>(entity).name,
        postfix,
        component::<Positioned, _>(entity).position,
    );
}


fn main() {
    let p = Player {  // TODO come up with a less verbose creation maybe?
        named: Named { name: String::from("Hugh") },
        positioned: Positioned { position: Vector2(42, 0) },
        displayed: Displayed { character: String::from("@") },
    };

    let g = Ghost {
        named: Named { name: String::from("Ghost") },
        positioned: Positioned { position: Vector2(0, 0) },
    };

    print_name_and_position(&p);
    print_name_and_position(&g);
}
