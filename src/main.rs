use crate::vector::Vector2;

mod vector;  // TODO figure out what to do with this thing


// ABSTRACT STUFF

trait HasComponent<T> {
    fn get_component_raw(&self) -> &T;
}

fn get_component<C, E: HasComponent<C>>(entity: &E) -> &C {
    HasComponent::<C>::get_component_raw(entity)
}


// COMPONENTS

struct Named {
    name: String,
}

struct Positioned {
    position: Vector2<i32>,
}


// ENTITIES

// ECS: components' types are parameters when defining new entity
struct Player {
    named: Named,
    positioned: Positioned,
}

// ECS: easily autogenerated code
impl HasComponent<Named> for Player {
    fn get_component_raw(&self) -> &Named {
        &self.named
    }
}

impl HasComponent<Positioned> for Player {
    fn get_component_raw(&self) -> &Positioned {
        &self.positioned
    }
}

// TODO print for multiple kinds of entities
// TODO print for multiple types
// TODO mutable components

// ECS better syntax like HasComponents<Named, Positioned> or has_components!(Named, Positioned)
fn print_name_and_position<T: HasComponent<Named> + HasComponent<Positioned>>(entity: &T) {
    println!(
        "{} at {}",
        get_component::<Named, _>(entity).name,
        get_component::<Positioned, _>(entity).position,
    );
}


fn main() {
    let e = Player {  // TODO come up with a less verbose creation maybe?
        named: Named { name: String::from("Hugh") },
        positioned: Positioned { position: Vector2(42, 0) }
    };

    print_name_and_position(&e);
}
