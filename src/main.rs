use crate::vector::Vector2;

mod vector;  // TODO figure out what to do with this thing


// ABSTRACT STUFF

trait HasComponent<T> {
    fn get_component_raw(&self) -> &T;
}

fn get_component<C, E: HasComponent<C>>(entity: &E) -> &C {
    HasComponent::<C>::get_component_raw(entity)
}


// COMPONENTS

struct Named {
    name: String,
}

struct Positioned {
    position: Vector2<i32>,
}

struct Displayed {
    character: String,
}


// ENTITIES

// ECS: components' types are parameters when defining new entity
struct Player {
    named: Named,
    positioned: Positioned,
    displayed: Displayed,
}

// ECS: easily autogenerated code
impl HasComponent<Named> for Player {
    fn get_component_raw(&self) -> &Named {
        &self.named
    }
}

impl HasComponent<Positioned> for Player {
    fn get_component_raw(&self) -> &Positioned {
        &self.positioned
    }
}

impl HasComponent<Displayed> for Player {
    fn get_component_raw(&self) -> &Displayed {
        &self.displayed
    }
}

struct Ghost {
    named: Named,
    positioned: Positioned,
}

// ECS: easily autogenerated code
impl HasComponent<Named> for Ghost {
    fn get_component_raw(&self) -> &Named {
        &self.named
    }
}

impl HasComponent<Positioned> for Ghost {
    fn get_component_raw(&self) -> &Positioned {
        &self.positioned
    }
}

// TODO print for multiple entities
// TODO mutable components
// TODO some characters, for example, can have health or not have health.
// TODO how to store them in a level?

// ECS better syntax like HasComponents<Named, Positioned> or has_components!(Named, Positioned)
fn print_name_and_position<T: HasComponent<Named> + HasComponent<Positioned>>(entity: &T) {
    println!(
        "{} at {}",
        get_component::<Named, _>(entity).name,
        get_component::<Positioned, _>(entity).position,
    );
}


fn main() {
    let p = Player {  // TODO come up with a less verbose creation maybe?
        named: Named { name: String::from("Hugh") },
        positioned: Positioned { position: Vector2(42, 0) },
        displayed: Displayed { character: String::from("@") },
    };

    println!("Player: {}", get_component::<Displayed, _>(&p).character);

    let g = Ghost {
        named: Named { name: String::from("Ghost") },
        positioned: Positioned { position: Vector2(0, 0) },
    };

    print_name_and_position(&p);
    print_name_and_position(&g);
}
