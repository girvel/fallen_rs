use crate::vector::Vector2;

mod vector;  // TODO figure out what to do with this thing


// ABSTRACT STUFF

trait HasComponent<T> {
    fn get_component(&self) -> &T;
}


// COMPONENTS

struct Named {
    name: String,
}

struct Positioned {
    position: Vector2<i32>,
}


// ENTITIES

// ECS: components' types are parameters when defining new entity
struct Player {
    named: Named,
    positioned: Positioned,
}

// ECS: easily autogenerated code
impl HasComponent<Named> for Player {
    fn get_component(&self) -> &Named {
        &self.named
    }
}

impl HasComponent<Positioned> for Player {
    fn get_component(&self) -> &Positioned {
        &self.positioned
    }
}

// TODO print for multiple kinds of entities
// TODO print for multiple types

fn print_name_and_position<T: HasComponent<Named> + HasComponent<Positioned>>(entity: &T) {
    println!("{} at {}",
        HasComponent::<Named>::get_component(entity).name,  // TODO better syntax
        HasComponent::<Positioned>::get_component(entity).position,
    );
}


fn main() {
    let e = Player {  // TODO come up with a less verbose creation maybe?
        named: Named { name: String::from("Hugh") },
        positioned: Positioned { position: Vector2(42, 0) }
    };

    print_name_and_position(&e);
}
